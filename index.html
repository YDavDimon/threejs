<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Three.js app</title>
		<style>
		body { margin: 0; }
		canvas { width: 100%; height: 100% }
		</style>
		<link rel="stylesheet" href="./css/style.css">
		
		
    </head>

    <body>

		
		<input type="checkbox" id="nav-toggle" hidden>

		<nav class="nav">
		
			<label for="nav-toggle" class="nav-toggle" onclick></label>
			
			<h2 class="logo"> 
				<a href="">menu</a> 
			</h2>
			<ul>
				<li> 
					
					<!-- Rounded switch -->
					<label class="switch">
					  <input type="checkbox" id="move_or_edit">
					  <span class="slider round"></span>
					  
					</label> 
					режим редактирования/перемещения
				<li> <!-- Rounded switch -->
					<label class="switch">
					  <input type="checkbox">
					  <span class="slider round"></span>
					</label> добавить/удалить

				<li> <!-- Rounded switch -->
					<label class="switch">
						
					  <input type="checkbox">
					  <span class="slider round"></span>
					</label> 
					включить визуализацию 
				
				
			</ul>
		</nav>
		

		<script type="module">
			import * as THREE from './build/three.module.js';
			import * as ThreeCSG from './js/ThreeCSG.js';
			import * as BufferGeometryUtils  from './js/BufferGeometryUtils.js';
			import {OrbitControls} from './js/jsm/controls/OrbitControls.js';
			import {DragControls} from './js/DragControls.js';
			import {FirstPersonControls} from './js/FirstPersonControls.js';
			import { FlyControls } from './js/jsm/controls/FlyControls.js'
			import { FontLoader } from './js/jsm/loaders/FontLoader.js';
			import { CSS2DObject, CSS2DRenderer } from './js/jsm/renderers/CSS2DRenderer.js';
			

			let camera, drag_controls, orbit_controls, container, scene, renderer, labelRenderer;

			let plane;
			let pointer, raycaster, isShiftDown = false;

			let rollOverMesh, rollOverMaterial;
			let cubeGeo, cubeMaterial;

			let enableSelection = false;


			const objects = [];
			const cubes = [];
			const snap_zones = [];
			
			const mouse = new THREE.Vector2();

			let checkbox_control; 
			checkbox_control = document.getElementById("move_or_edit");
			

			init();
			animate();


			

			function init() {
				checkbox_control.checked = true;

				container = document.getElementById( 'container' );
				//scene
				
				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x000 );

				

				//camera

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.set( 10, 20, 1 );
				camera.lookAt(0, 0, 0);
				


				// lights

				let spotLight = new THREE.SpotLight(0xffffff);
				spotLight.position.set(100, 100, 100);
				scene.add(spotLight);	

				let spotLight2 = new THREE.SpotLight(0xffffff);
				spotLight2.position.set( -200, -200, -200);
				scene.add(spotLight2);
				

				//renderer

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );
			
				labelRenderer = new CSS2DRenderer();
				labelRenderer.setSize( window.innerWidth, window.innerHeight );
				labelRenderer.domElement.style.position = 'absolute';
				labelRenderer.domElement.style.top = '0px';
				labelRenderer.domElement.style.pointerEvents = 'none'
				document.body.appendChild( labelRenderer.domElement );

				

				window.addEventListener( 'resize', onWindowResize );
				document.addEventListener( 'pointermove', onPointerMove );
				document.addEventListener( 'pointerdown', onPointerDown );
				document.addEventListener( 'pointerup', onPointerUp );
				
				//controls

				drag_controls = new DragControls( cubes, camera, renderer.domElement );				

				// controls2 = new FirstPersonControls( camera, renderer.domElement );
				// controls2.movementSpeed = 5;
				// controls2.heightMax =0.1;
				// controls2.lookSpeed = 0.05;
				

				orbit_controls = new OrbitControls( camera, renderer.domElement );

				
				
				

				//axes

				const axesHelper = new THREE.AxesHelper( 100 );
				axesHelper.position.y = 0.25;
				scene.add( axesHelper );
	
				
				

				// grid

				const gridHelper1 = new THREE.GridHelper( 60, 60, 0xffffff, 0xffffff);
				gridHelper1.position.y = 0.25;
				scene.add(  gridHelper1 );

				//geometries
							
				const geometry_box_horizontal = new THREE.BoxGeometry(60,0.5,40 );
				const geometry_box_vertical = new THREE.BoxGeometry( 10, 0.2, 40 ); 
				const geometry_box_vertical2 = new THREE.BoxGeometry(60, 0.2, 10 );
				const geometry_box_vertical_inside_1 = new THREE.BoxGeometry(10, 0.2, 18 );
				const geometry_box_vertical_inside_2 = new THREE.BoxGeometry(10, 0.2, 25 );
				

				//materials

				const loader_texture = new THREE.TextureLoader();	
				const loader = new THREE.TextureLoader();

				const capsule_material = new THREE.MeshPhongMaterial({
					color: 0x000000,
					side: THREE.DoubleSide,
				});

				cubeMaterial = new THREE.MeshPhongMaterial({
					color: 0xff0000
				});
				
				const material_floor = [
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/concrete.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/concrete.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/texture_floor.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/concrete.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/concrete.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/concrete.jpg'),
				side: THREE.DoubleSide
				} ),
				];
				
				const material_walls_outside_right = [
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/concrete.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/concrete.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/concrete.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/texture_inside.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/concrete.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/concrete.jpg'),
				side: THREE.DoubleSide
				} ),
				];

				const material_walls_outside_left = [
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/concrete.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/concrete.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/texture_inside.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/concrete.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/concrete.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/concrete.jpg'),
				side: THREE.DoubleSide
				} ),
				];
				 
				const material_walls_inside = [
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/concrete.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/concrete.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/texture_inside.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/texture_inside.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/concrete.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/concrete.jpg'),
				side: THREE.DoubleSide
				} ),
				];

				const material_back_wall = [
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/concrete.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/concrete.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/texture_inside.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/texture_outside.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/concrete.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/concrete.jpg'),
				side: THREE.DoubleSide
				} ),
				];

				const material_beacon =  new THREE.MeshPhongMaterial({color: 0xff0000});
				const material_sphere =  new THREE.MeshBasicMaterial({color: 0xfafafa, transparent: true, opacity: 0.5});
				//mesh add

				function add_object(geometry, material, angle_x, angle_y, angle_z, pos_x, pos_y, pos_z) {
					const mesh_object = new THREE.Mesh( geometry, material);
					var angle_x_rad = Math.PI / 180 * angle_x;
					var angle_y_rad = Math.PI / 180 * angle_y;
					var angle_z_rad = Math.PI / 180 * angle_z;
					mesh_object.rotation.set(angle_x_rad, angle_y_rad, angle_z_rad);
					mesh_object.position.set(pos_x, pos_y, pos_z);
					scene.add(mesh_object);

					return mesh_object;
				}



				//beacons add

				const beacon_geometry =new THREE.SphereGeometry(0.2, 32, 32, 0, Math.PI);
				const box_geometry =new THREE.BoxGeometry(1, 0.1, 1);
				add_object(beacon_geometry, material_beacon, 0, 0, 0, 25, 8, 2.1);
				add_object(beacon_geometry, material_beacon, 0, 0, 0, 15, 8, 2.1);
				add_object(beacon_geometry, material_beacon, 0, 0, 0, 5, 8, 2.1);
				add_object(beacon_geometry, material_beacon, 0, 180, 0, 25, 8, 19.9);
				add_object(beacon_geometry, material_beacon, 0, 180, 0, 15, 8, 19.9);
				add_object(beacon_geometry, material_beacon, 0, 180, 0, 5, 8, 19.9);
				add_object(beacon_geometry, material_beacon, 0, 90, 0, 0.1, 8, 10);
				add_object(beacon_geometry, material_beacon, 0, -90, 0, 29.9, 8, 10);
				add_object(box_geometry, material_walls_outside_right, 0, 0, 0, 15, 10, 10);
				add_object(beacon_geometry, material_beacon, 90, 0, 0, 15, 10, 10);
				add_object(box_geometry, material_walls_outside_right, 0, 0, 0, 25, 10, 10);
				add_object(beacon_geometry, material_beacon, 90, 0, 0, 25, 10, 10);
				add_object(box_geometry, material_walls_outside_right, 0, 0, 0, 5, 10, 10);
				add_object(beacon_geometry, material_beacon, 90, 0, 0, 5, 10, 10);


				add_object(beacon_geometry, material_beacon, 0, 180, 0, 25, 8, -2.1);
				add_object(beacon_geometry, material_beacon, 0, 180, 0, 15, 8, -2.1);
				add_object(beacon_geometry, material_beacon, 0, 180, 0, 5, 8, -2.1);
				add_object(beacon_geometry, material_beacon, 0, 0, 0, 25, 8, -19.9);
				add_object(beacon_geometry, material_beacon, 0, 0, 0, 15, 8, -19.9);
				add_object(beacon_geometry, material_beacon, 0, 0, 0, 5, 8, -19.9);
				add_object(beacon_geometry, material_beacon, 0, 90, 0, 0.1, 8, -10);
				add_object(beacon_geometry, material_beacon, 0, -90, 0, 29.9, 8, -10);
				add_object(box_geometry, material_walls_outside_right, 0, 0, 0, 15, 10, -10);
				add_object(beacon_geometry, material_beacon, 90, 0, 0, 15, 10, -10);
				add_object(box_geometry, material_walls_outside_right, 0, 0, 0, 25, 10, -10);
				add_object(beacon_geometry, material_beacon, 90, 0, 0, 25, 10, -10);
				add_object(box_geometry, material_walls_outside_right, 0, 0, 0, 5, 10, -10);
				add_object(beacon_geometry, material_beacon, 90, 0, 0, 5, 10, -10);



				add_object(beacon_geometry, material_beacon, 0, 180, 0, -5, 8, -2.1);
				add_object(beacon_geometry, material_beacon, 0, 180, 0, -15, 8, -2.1);
				add_object(beacon_geometry, material_beacon, 0, 0, 0, -5, 8, -19.9);
				add_object(beacon_geometry, material_beacon, 0, 0, 0, -15, 8, -19.9);
				add_object(beacon_geometry, material_beacon, 0, 90, 0, -20, 8, 10);
				add_object(box_geometry, material_walls_outside_right, 0, 0, 0, -5, 10, -10);
				add_object(beacon_geometry, material_beacon, 90, 0, 0, -5, 10, -10);
				add_object(box_geometry, material_walls_outside_right, 0, 0, 0, -15, 10, -10);
				add_object(beacon_geometry, material_beacon, 90, 0, 0, -15, 10, -10);
				

				add_object(beacon_geometry, material_beacon, 0, 0, 0, -5, 8, 2.1);
				add_object(beacon_geometry, material_beacon, 0, 0, 0, -15, 8, 2.1);
				add_object(beacon_geometry, material_beacon, 0, 180, 0, -5, 8, 19.9);
				add_object(beacon_geometry, material_beacon, 0, 180, 0, -15, 8, 19.9);
				add_object(beacon_geometry, material_beacon, 0, 90, 0, -20, 8, -10);
				add_object(box_geometry, material_walls_outside_right, 0, 0, 0, -5, 10, 10);
				add_object(beacon_geometry, material_beacon, 90, 0, 0, -5, 10, 10);
				add_object(box_geometry, material_walls_outside_right, 0, 0, 0, -15, 10, 10);
				add_object(beacon_geometry, material_beacon, 90, 0, 0, -15, 10, 10);

				add_object(beacon_geometry, material_beacon, 0, 90, 0, -29.9, 8, 2.1);
				add_object(beacon_geometry, material_beacon, 0, 180, 0, -29.9, 8, 19.9);
				add_object(box_geometry, material_walls_outside_right, 0, 0, 0, -25, 10, 10);
				add_object(beacon_geometry, material_beacon, 90, 0, 0, -25, 10, 10);

				add_object(beacon_geometry, material_beacon, 0, 90, 0, -29.9, 8, -2.1);
				add_object(beacon_geometry, material_beacon, 0, 0, 0, -29.9, 8, -19.9);
				add_object(box_geometry, material_walls_outside_right, 0, 0, 0, -25, 10, -10);
				add_object(beacon_geometry, material_beacon, 90, 0, 0, -25, 10, -10);


				//sphere add
				

				const sphere_geometry =new THREE.SphereGeometry(10  , 32, 32);
				// add_object(sphere_geometry, material_sphere, 0, 0, 0, 25, 8, 2.1);
				// add_object(sphere_geometry, material_sphere, 0, 0, 0, 15, 8, 2.1);
				// add_object(sphere_geometry, material_sphere, 0, 0, 0, 5, 8, 2.1);
				// add_object(sphere_geometry, material_sphere, 0, 180, 0, 25, 8, 19.9);
				// add_object(sphere_geometry, material_sphere, 0, 180, 0, 15, 8, 19.9);
				// add_object(sphere_geometry, material_sphere, 0, 180, 0, 5, 8, 19.9);
				// add_object(sphere_geometry, material_sphere, 0, 90, 0, 0.1, 8, 10);
				// add_object(sphere_geometry, material_sphere, 0, -90, 0, 29.9, 8, 10);
				// add_object(sphere_geometry, material_sphere, 0, 0, 0, 15, 10, 10);
				// add_object(sphere_geometry, material_sphere, 90, 0, 0, 15, 10, 10);
				

				// add_object(sphere_geometry, material_sphere, 0, 180, 0, -5, 8, -2.1);
				// add_object(sphere_geometry, material_sphere, 0, 180, 0, -15, 8, -2.1);
				// add_object(sphere_geometry, material_sphere, 0, 0, 0, -5, 8, -19.9);
				// add_object(sphere_geometry, material_sphere, 0, 0, 0, -15, 8, -19.9);

				//side walls
				const geometry_box_outside_walls_up_1 = new THREE.BoxGeometry(5, 0.2, 40 );
				const geometry_box_outside_walls_down_11 = new THREE.BoxGeometry(5, 0.2, 6 );
				const geometry_box_outside_walls_down_12 = new THREE.BoxGeometry(5, 0.2, 16 );
				const geometry_box_outside_walls_down_13 = new THREE.BoxGeometry(5, 0.2, 28 );

				add_object(geometry_box_outside_walls_up_1,  material_walls_outside_right, 0, 0, 90, 30, 7.5, 0 );
				add_object(geometry_box_outside_walls_down_11,  material_walls_outside_right, 0, 0, 90, 30, 2.5, 17 );
				add_object(geometry_box_outside_walls_down_12,  material_walls_outside_right, 0, 0, 90, 30, 2.5, 0 );
				add_object(geometry_box_outside_walls_down_11,  material_walls_outside_right, 0, 0, 90, 30, 2.5, -17 );

				add_object(geometry_box_outside_walls_up_1,  material_walls_outside_right, 0, 0, 90, -30, 7.5, 0 );
				add_object(geometry_box_outside_walls_down_11,  material_walls_outside_right, 0, 0, 90, -30, 2.5, 17 );
				add_object(geometry_box_outside_walls_down_13,  material_walls_outside_right, 0, 0, 90, -30, 2.5, -6 );
				
				//floor
				plane = add_object(geometry_box_horizontal, material_floor, 0, 0, 0, 0, 0, 0 );
				objects.push(plane);
				snap_zones.push(plane);


				//front and back walls

				const geometry_box_outside_walls_up_2 = new THREE.BoxGeometry(60, 0.2, 5);
				const geometry_box_outside_walls_down_21 = new THREE.BoxGeometry(12, 0.2, 5 );
				const geometry_box_outside_walls_down_22 = new THREE.BoxGeometry(19, 0.2, 5 );
				const geometry_box_outside_walls_down_23 = new THREE.BoxGeometry(16, 0.2, 5 );
				const geometry_box_outside_walls_down_24 = new THREE.BoxGeometry(1, 0.2, 3 );
				const geometry_box_outside_walls_down_25 = new THREE.BoxGeometry(17, 0.2, 5 );

				add_object(geometry_box_outside_walls_up_2,  material_back_wall, 90, 0, 0, 0, 7.5, -20 );
				add_object(geometry_box_outside_walls_down_21,  material_back_wall, 90, 0, 0, 24, 2.5, -20 );
				add_object(geometry_box_outside_walls_down_22,  material_back_wall, 90, 0, 0, 2.5, 2.5, -20 );
				add_object(geometry_box_outside_walls_down_23,  material_back_wall, 90, 0, 0, -21, 2.5, -20 );
				add_object(geometry_box_outside_walls_down_24,  material_back_wall, 90, 0, 0, -29.5, 3.5, -20 );

				add_object(geometry_box_outside_walls_up_2,  material_back_wall, 90, 0, 0, 0, 7.5, 20 );
				add_object(geometry_box_outside_walls_down_21,  material_back_wall, 90, 0, 0, 24, 2.5, 20 );
				add_object(geometry_box_outside_walls_down_22,  material_back_wall, 90, 0, 0, 2.5, 2.5, 20 );
				add_object(geometry_box_outside_walls_down_25,  material_back_wall, 90, 0, 0, -21.5, 2.5, 20 );
		

				//inside walls geometry

				const geometry_box_inside_walls_up_3 = new THREE.BoxGeometry(5, 0.2, 40);
				const geometry_box_inside_walls_down_31 = new THREE.BoxGeometry(5, 0.2, 18);
				const geometry_box_inside_walls_up_4 = new THREE.BoxGeometry(5, 0.2, 60);
				const geometry_box_inside_walls_down_41 = new THREE.BoxGeometry(5, 0.2, 26);
				const geometry_box_inside_walls_down_42 = new THREE.BoxGeometry(5, 0.2, 16);
				const geometry_box_inside_walls_down_43 = new THREE.BoxGeometry(5, 0.2, 6);
				const geometry_box_inside_walls_down_44 = new THREE.BoxGeometry(5, 0.2, 8);
				const geometry_box_inside_walls_down_45 = new THREE.BoxGeometry(3, 0.2, 2);

				//office rooms geometry
				const geometry_box_inside_walls_up_51 = new THREE.BoxGeometry(8, 0.2, 18);
				const geometry_box_inside_walls_down_51 = new THREE.BoxGeometry(2, 0.2, 6);
				const geometry_box_inside_walls_down_52 = new THREE.BoxGeometry(2, 0.2, 3);
				const geometry_box_inside_walls_up_52 = new THREE.BoxGeometry(8, 0.2, 10);
				



				add_object(geometry_box_inside_walls_up_3,  material_back_wall, 0, 0, 90, -20, 7.5, 0 );
				add_object(geometry_box_inside_walls_down_31,  material_back_wall, 0, 0, 90, -20, 2.5, 11 );
				add_object(geometry_box_inside_walls_down_31,  material_back_wall, 0, 0, 90, -20, 2.5, -11 );

				add_object(geometry_box_inside_walls_up_3,  material_back_wall, 0, 0, 90, 0, 7.5, 0 );
				add_object(geometry_box_inside_walls_down_31,  material_back_wall, 0, 0, 90, 0, 2.5, 11 );
				add_object(geometry_box_inside_walls_down_31,  material_back_wall, 0, 0, 90, 0, 2.5, -11 );

				add_object(geometry_box_inside_walls_up_4,  material_back_wall, 90, 90, 0, 0, 7.5, 2 );
				add_object(geometry_box_inside_walls_down_41,  material_back_wall, 90, 90, 0, 17, 2.5, 2 );

				add_object(geometry_box_inside_walls_up_4,  material_back_wall, 90, 90, 0, 0, 7.5, -2 );
				add_object(geometry_box_inside_walls_down_41,  material_back_wall, 90, 90, 0, 17, 2.5, -2 );

				add_object(geometry_box_inside_walls_down_42,  material_back_wall, 90, 90, 0, -12, 2.5, -2 );
				add_object(geometry_box_inside_walls_down_42,  material_back_wall, 90, 90, 0, -12, 2.5, 2 );

				add_object(geometry_box_inside_walls_down_43,  material_back_wall, 90, 90, 0, -27, 2.5, 2 );

				add_object(geometry_box_inside_walls_down_44,  material_back_wall, 90, 90, 0, -24, 2.5, -2 );

				add_object(geometry_box_inside_walls_down_45,  material_back_wall, 90, 90, 0, -29, 3.5, -2 );

				add_object(geometry_box_inside_walls_up_51,  material_back_wall, 0, 0, 90, -28, 6, -11 );
				add_object(geometry_box_inside_walls_up_52,  material_back_wall, 90, 0, 0, -24, 5, -13);
				add_object(geometry_box_inside_walls_up_52,  material_back_wall, 90, 0, 0, -24, 5, -9);

				add_object(geometry_box_inside_walls_down_51,  material_back_wall, 0, 0, 90, -28, 1, -16);
				add_object(geometry_box_inside_walls_down_51,  material_back_wall, 0, 0, 90, -28, 1, -5);
				add_object(geometry_box_inside_walls_down_52,  material_back_wall, 0, 0, 90, -28, 1, -10.5);

				// racks
				const geometry_rack = new THREE.BoxGeometry(5, 0.1, 2);
				

				function create_rack(pos_x, pos_z) {

					const geometry_vertical = new THREE.BoxGeometry(0.2, 10, 0.2);
					const geometry_horizontal = new THREE.BoxGeometry(5, 0.2, 2);

					 add_object(geometry_vertical,  material_back_wall, 0, 0, 0, pos_x-2.5, 5, pos_z-1);
					 add_object(geometry_vertical,  material_back_wall, 0, 0, 0, pos_x-2.5, 5, pos_z+1);
					 add_object(geometry_vertical,  material_back_wall, 0, 0, 0, pos_x+2.5, 5, pos_z-1);
					 add_object(geometry_vertical,  material_back_wall, 0, 0, 0, pos_x+2.5, 5, pos_z+1);

					 const horizontal_1 = add_object(geometry_horizontal,  material_back_wall, 0, 0, 0,pos_x, 3, pos_z);
					 objects.push(horizontal_1);
					 snap_zones.push(horizontal_1);
					 const horizontal_2 = add_object(geometry_horizontal,  material_back_wall, 0, 0, 0, pos_x, 6, pos_z);
					 objects.push(horizontal_2);
					 snap_zones.push(horizontal_2);
					 const horizontal_3 = add_object(geometry_horizontal,  material_back_wall, 0, 0, 0, pos_x, 9, pos_z);
					 objects.push(horizontal_3);
					 snap_zones.push(horizontal_3);

				}

				create_rack(23, -7);
				create_rack(18, -7);
				create_rack(13, -7);
				create_rack(8, -7);

				create_rack(23, -15);
				create_rack(18, -15);
				create_rack(13, -15);
				create_rack(8, -15);

				create_rack(23, 7);
				create_rack(18, 7);
				create_rack(13, 7);
				create_rack(8, 7);

				create_rack(23, 15);
				create_rack(18, 15);
				create_rack(13, 15);
				create_rack(8, 15);

				create_rack(-7, 15);
				create_rack(-12, 15);
				
				create_rack(-7, 7);
				create_rack(-12, 7);

				create_rack(-7, -15);
				create_rack(-12, -15);
				
				create_rack(-7, -7);
				create_rack(-12, -7);

				create_rack(-23, 7);

				create_rack(-23, 15);
				
				
			
				// roll-over helpers

				const rollOverGeo = new THREE.BoxGeometry( 1, 1, 1 );
				rollOverMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000, opacity: 0.5, transparent: true } );
				rollOverMesh = new THREE.Mesh( rollOverGeo, rollOverMaterial );
				scene.add( rollOverMesh );
				cubes.push(rollOverMesh);

				// cubes

				
				cubeGeo = new THREE.BoxGeometry( 1, 1, 1 );
				

				//

				raycaster = new THREE.Raycaster();
				pointer = new THREE.Vector2();
				

			}


			//
			
			function findClosestTarget(position, targets) {
				let closestTarget = null;
				let closestDistance = Infinity;

				for (let i = 0; i < targets.length; i++) {
					const target = targets[i];
			
					const distance = position.distanceTo(target.position);

					if (distance < closestDistance) {
					closestTarget = target;
					closestDistance = distance;
					}
				}

				return closestTarget;
				}

			//

			
			drag_controls.addEventListener('drag', function (event) {
				const object = event.object;
				const position = object.position.clone();
				const closestTarget = findClosestTarget(position, snap_zones); // Находим ближайший целевой объект
				if (closestTarget) {
					object.position.y = closestTarget.position.y;
					object.position.add(new THREE.Vector3(0, 0.75, 0 ))
					//object.position.copy(closestTarget.position); // Привязываем позицию объекта к позиции ближайшего целевого объекта
					
				}
			});
			

			function onPointerMove( event ) {

				if (checkbox_control.checked) {

					drag_controls.enabled = false;
					orbit_controls.enabled = false;

					pointer.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );
					raycaster.setFromCamera( pointer, camera );
					const intersects = raycaster.intersectObjects( objects, false );

					if ( intersects.length > 0 ) {

						const intersect = intersects[ 0 ];
						rollOverMesh.position.copy( intersect.point ).add( intersect.face.normal );

						if ( intersect.object == plane ) {
							
							rollOverMesh.position.round().add(new THREE.Vector3( 0.5, -0.25, 0.5 ));
						}

						else {
							rollOverMesh.position.round().add(new THREE.Vector3( 0.5, -0.4, 0.5 ));
						}
					

					}

				}

				else {
					
					drag_controls.enabled = true;
					
					pointer.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );
					raycaster.setFromCamera( pointer, camera );
					const intersects = raycaster.intersectObjects( cubes, false );

					if ( intersects.length > 0 ) {
						orbit_controls.enabled = false;
					}

					else {
						orbit_controls.enabled = true;
					}


				}

			}


			function onPointerDown( event ) {

				if (checkbox_control.checked) {
					drag_controls.enabled =false;
					
					pointer.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );
					raycaster.setFromCamera( pointer, camera );
					const intersects = raycaster.intersectObjects( objects, false );

					if ( intersects.length > 0 ) {

						const intersect = intersects[ 0 ];
						const voxel = new THREE.Mesh( cubeGeo, cubeMaterial);
						voxel.position.copy( intersect.point ).add( intersect.face.normal );

							if ( intersect.object == plane ) {
								voxel.position.round().add(new THREE.Vector3( 0.5, -0.25, 0.5 ));
								scene.add(voxel);
								objects.push(voxel);
								cubes.push(voxel);
								
							}

							else {
							voxel.position.round().add(new THREE.Vector3( 0.5, -0.4, 0.5 ));
							scene.add(voxel);
							objects.push(voxel);
							cubes.push(voxel);
							}

					}
				}

				else {
					drag_controls.enabled =true;
				}

				

			}

			function onPointerUp(event) {
				

			}
			
			


		


			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
				

			}

			function animate() {
				requestAnimationFrame( animate );
				orbit_controls.update(0.05); 
				
				
				render();

			}

			function render() {
				renderer.render( scene, camera );
				camera.updateMatrixWorld();
			}

			

		</script>
		
    </body>
</html>