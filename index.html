<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Three.js app</title>
		<style>
		body { margin: 0; }
		canvas { width: 100%; height: 100% }
		</style>
		<link rel="stylesheet" href="./css/style.css">
    </head>

    <body>
		
		
		<script type="module">
		
			import * as THREE from './build/three.module.js';
			import {OrbitControls} from './js/jsm/controls/OrbitControls.js';
			import { FontLoader } from './js/jsm/loaders/FontLoader.js';
			import { CSS2DObject, CSS2DRenderer } from './js/jsm/renderers/CSS2DRenderer.js';
			

			let camera, controls, scene, renderer, labelRenderer;

			init();
			animate();

			function init() {

				//scene

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x000 );

				

				//camera

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.set( 10, 10, 20 );

				

				//axes

				const axesHelper = new THREE.AxesHelper( 100 );
				axesHelper.position.y = 0.25;
				scene.add( axesHelper );
	
				
				

				// grid

				const gridHelper1 = new THREE.GridHelper( 60, 60, 0xffffff, 0xffffff);
				const gridHelper2 = new THREE.GridHelper( 60, 60, 0xffffff, 0xffffff);
				gridHelper1.position.y = 0.25;
				gridHelper2.position.y = 8.25;
				scene.add(  gridHelper2 );

				//geometries
							
				const geometry_box_horizontal = new THREE.BoxGeometry(60,0.5,40 );
				const geometry_box_vertical = new THREE.BoxGeometry( 16, 0.2, 40 ); 
				const geometry_box_vertical2 = new THREE.BoxGeometry(60, 0.2, 16 );
				const geometry_box_vertical_inside_1 = new THREE.BoxGeometry(16, 0.2, 18 );
				const geometry_box_vertical_inside_2 = new THREE.BoxGeometry(16, 0.2, 25 );
				

				//materials for objects	

				const loader_texture = new THREE.TextureLoader();	
				const loader = new THREE.TextureLoader();

				const capsule_material = new THREE.MeshPhongMaterial({
					color: 0x000000,
					side: THREE.DoubleSide,
				});
				
				const material_floor = [
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/concrete.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/concrete.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/texture_floor.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/concrete.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/concrete.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/concrete.jpg'),
				side: THREE.DoubleSide
				} ),
				];
				
				const material_walls_outside_right = [
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/concrete.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/concrete.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/concrete.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/texture_inside.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/concrete.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/concrete.jpg'),
				side: THREE.DoubleSide
				} ),
				];

				const material_walls_outside_left = [
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/concrete.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/concrete.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/texture_inside.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/concrete.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/concrete.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/concrete.jpg'),
				side: THREE.DoubleSide
				} ),
				];
				 
				const material_walls_inside = [
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/concrete.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/concrete.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/texture_inside.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/texture_inside.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/concrete.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/concrete.jpg'),
				side: THREE.DoubleSide
				} ),
				];

				const material_back_wall = [
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/concrete.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/concrete.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/texture_inside.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/texture_outside.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/concrete.jpg'),
				side: THREE.DoubleSide
				} ),
				new THREE.MeshPhongMaterial( {
				map: loader_texture.load('./sources/textures/concrete.jpg'),
				side: THREE.DoubleSide
				} ),
				];
				 
				//mesh

				function add_object(geometry, material, angle_x, angle_y, angle_z, pos_x, pos_y, pos_z) {
					const mesh_object = new THREE.Mesh( geometry, material);
					var angle_x_rad = Math.PI / 180 * angle_x;
					var angle_y_rad = Math.PI / 180 * angle_y;
					var angle_z_rad = Math.PI / 180 * angle_z;
					mesh_object.rotation.set(angle_x_rad, angle_y_rad, angle_z_rad);
					mesh_object.position.set(pos_x, pos_y, pos_z);
					scene.add(mesh_object);

				}

				add_object(geometry_box_horizontal, material_floor, 0, 0, 0, 0, 0, 0 );
				add_object(geometry_box_horizontal, material_floor, 0, 0, 0, 0, 8, 0 );

				add_object(geometry_box_vertical,  material_walls_outside_right, 0, 0, 90, -30, 8, 0 );
				add_object(geometry_box_vertical,  material_walls_outside_left, 0, 0, 90, 30, 8, 0 );
				add_object(geometry_box_vertical2,  material_back_wall, 90, 180, 0, 0, 8, -20 );

				add_object(geometry_box_vertical_inside_1,  material_back_wall, 0, 0, 90, -20, 8, 11 );
				add_object(geometry_box_vertical_inside_1,  material_back_wall, 0, 0, 90, -20, 8, -11 );
				add_object(geometry_box_vertical_inside_1,  material_back_wall, 0, 0, 90, 0, 8, 11 );
				add_object(geometry_box_vertical_inside_1,  material_back_wall, 0, 0, 90, 0, 8, -11 );

				add_object(geometry_box_vertical_inside_2,  material_back_wall, 90, 90, 0, 17.5, 8, 2 );
				add_object(geometry_box_vertical_inside_2,  material_back_wall, 90, 90, 0, 17.5, 8, -2 );
				add_object(geometry_box_vertical_inside_2,  material_back_wall, 90, 90, 0, -17.5, 8, 2 );
				add_object(geometry_box_vertical_inside_2,  material_back_wall, 90, 90, 0, -17.5, 8, -2 );
				
				

				// Создание геометрии ступенек
				var stepWidth = 0.2;
				var stepHeight = 0.2;
				var stepDepth = 1;
				var stepCount = 10;
				var stepGeometry = new THREE.BoxGeometry(stepWidth, stepHeight, stepDepth);

				// Создание массива для хранения ступенек
				var steps = [];

				// Создание ступенек и добавление их в массив
				for (var i = 0; i < stepCount; i++) {
					var stepMesh = new THREE.Mesh(stepGeometry, material_back_wall);
					stepMesh.position.y = 8.25 + i * stepHeight;
					stepMesh.position.x = i * stepWidth;
					steps.push(stepMesh);
				}

				// Добавление ступенек на сцену
				for (var i = 0; i < steps.length; i++) {
					scene.add(steps[i]);
				}

				// Создание куба
				var cubeGeometry = new THREE.BoxGeometry(10, 10, 10);
				var cubeMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
				var cube = new THREE.Mesh(cubeGeometry, cubeMaterial);

				// Создание сферы для вычитания из куба
				var sphereGeometry = new THREE.SphereGeometry(5, 32, 32);
				var sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
				var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
				sphere.position.set(0, 0, 0);

				// Преобразование геометрий в ThreeCSG объекты
				var cubeCSG = new ThreeBSP(cube);
				var sphereCSG = new ThreeBSP(sphere);

				// Вычитание сферы из куба
				var resultCSG = cubeCSG.subtract(sphereCSG);

				// Преобразование ThreeCSG объекта обратно в Three.js объект
				var resultGeometry = resultCSG.toGeometry();
				var resultMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
				var resultMesh = new THREE.Mesh(resultGeometry, resultMaterial);

				// Добавление результирующего объекта на сцену
				scene.add(resultMesh);

				
				
				
				
				// lights

				let spotLight = new THREE.SpotLight(0xffffff);
				spotLight.position.set(100, 100, 100);
				scene.add(spotLight);	

				let spotLight2 = new THREE.SpotLight(0xffffff);
				spotLight2.position.set( -200, -200, -200);
				scene.add(spotLight2);
				

				//renderer

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );
			

				controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 5;
				controls.maxDistance = 50;
				controls.maxPolarAngle = Math.PI/2;

				labelRenderer = new CSS2DRenderer();
				labelRenderer.setSize( window.innerWidth, window.innerHeight );
				labelRenderer.domElement.style.position = 'absolute';
				labelRenderer.domElement.style.top = '0px';
				labelRenderer.domElement.style.pointerEvents = 'none'
				document.body.appendChild( labelRenderer.domElement );

				window.addEventListener( 'resize', onWindowResize );


			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {
				requestAnimationFrame( animate );
				controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true
				render();

			}

			function render() {
				renderer.render( scene, camera );
				labelRenderer.render( scene, camera );
			}

			

		</script>
		
    </body>
</html>